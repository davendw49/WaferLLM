param memcpy_params: comptime_struct;
param comm_params: comptime_struct;

param P: i16;
param L: i16;
param Mt: i16;
param Nt: i16;

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const layout_module = @import_module("<layout>");

const comm_mod = @import_module("comm_lib/comm_pe.csl", @concat_structs(comm_params, .{
    .P = P, .L = L, .Mt = Mt, .Nt = Nt, 
}));

var px: i16 = 0;
var py: i16 = 0;

var W_tile: [Mt*Nt]f16 = @zeros([Mt*Nt]f16);
var ptr_W: [*]f16 = &W_tile;
var W_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt*Nt} -> W_tile[i] });

var tmp_tile: [Mt*Nt]f16 = @zeros([Mt*Nt]f16);
var ptr_tmp: [*]f16 = &tmp_tile;
var tmp_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt*Nt} -> tmp_tile[i] });

var res_tile: [Mt*Nt]f16 = @zeros([Mt*Nt]f16);
var ptr_res: [*]f16 = &res_tile;

const timestamp = @import_module("<time>");
var tscStartBuffer = @zeros([timestamp.tsc_size_words]u16);
var tscEndBuffer = @zeros([timestamp.tsc_size_words]u16);
var time_buf_f32 = @zeros([3]f32);
var ptr_time_memcpy: [*]f32 = &time_buf_f32;

fn init_task() void {
    timestamp.enable_tsc();
    @assert(P >= 3);
    px = @as(i16, layout_module.get_x_coord());
    py = @as(i16, layout_module.get_y_coord());
  
    comm_mod.init_(px, py);
    sys_mod.unblock_cmd_stream();
}

fn shift_communication() void {
    @fmovh(tmp_dsd, W_dsd);
    comm_mod.right_matrix_shift(ptr_tmp, ptr_res);
    comm_mod.left_broadcast();
    shift_entry();
}

var total_repeat_times: i16 = 1;
var total_warmup_times: i16 = 0;

var repeat_times: i16 = 0; // Start from 0

fn shift_host(total_warmup_times_: i16, total_repeat_times_: i16) void {
    total_repeat_times = total_repeat_times_;
    total_warmup_times = total_warmup_times_;

    repeat_times = 0;

    shift_entry();
}

fn shift_entry() void {

    // Run (total_warmup_times + total_repeat_times) times; only the last `total_repeat_times` iterations are timed
    if (repeat_times == total_repeat_times + total_warmup_times) {
        exit();
    } else {
        if (repeat_times == total_warmup_times) {
            timestamp.get_timestamp(&tscStartBuffer);
        }

        repeat_times += 1;
        shift_communication();
    }
}

fn exit() void {
    timestamp.get_timestamp(&tscEndBuffer);
    timestamp.disable_tsc();

    f_memcpy_timestamps();
    sys_mod.unblock_cmd_stream();
}

fn f_memcpy_timestamps() void {
    var lo_ : u16 = 0;
    var hi_ : u16 = 0;
    var word : u32 = 0;

    lo_ = tscStartBuffer[0];
    hi_ = tscStartBuffer[1];
    time_buf_f32[0] = @bitcast(f32, (@as(u32,hi_) << @as(u16,16)) | @as(u32, lo_) );

    lo_ = tscStartBuffer[2];
    hi_ = tscEndBuffer[0];
    time_buf_f32[1] = @bitcast(f32, (@as(u32,hi_) << @as(u16,16)) | @as(u32, lo_) );

    lo_ = tscEndBuffer[1];
    hi_ = tscEndBuffer[2];
    time_buf_f32[2] = @bitcast(f32, (@as(u32,hi_) << @as(u16,16)) | @as(u32, lo_) );
}

comptime {
    @export_symbol(ptr_W, "W");
    @export_symbol(ptr_res, "res");

    @export_symbol(init_task);
    @export_symbol(shift_host);

    @export_symbol(ptr_time_memcpy, "time_memcpy");
}