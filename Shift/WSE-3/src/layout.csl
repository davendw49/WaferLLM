param P: i16;
param L: i16;
param Mt: i16;
param Nt: i16;

const C_R_0: color = @get_color(5);
const C_R_1: color = @get_color(6);

const C_L_B: color = @get_color(7);

const memcpy = @import_module( "<memcpy/get_params>", .{
    .width = P+L,
    .height = P,
});

const comm = @import_module("comm_lib/comm_layout.csl", .{
    .P = P,
    .L = L,
    .x_colors = [2]color{C_R_0, C_R_1},
});

layout {
    @set_rectangle(P+L, P);

    var px: i16 = 0;
    var py: i16 = 0;

    const comm_even = comm.get_step_params(true);
    const comm_odd = comm.get_step_params(false);

    px = 0;
    while (px < P+L) : (px += 2) {
        const memcpy_params = memcpy.get_params(px);

        py = 0;
        while (py < P) : (py += 1) {

            @set_tile_code(px, py, "shift.csl", .{
                .memcpy_params = memcpy_params,
                .comm_params = @concat_structs(comm_even, .{.left_bd_color = C_L_B}),
                .P = P, .L = L, .Mt = Mt, .Nt = Nt,
            });

            if (px == (P+L-1)) {
                @set_color_config(px, py, C_L_B, .{ .routes = .{ .rx = .{RAMP}, .tx = .{WEST} } });
            } else if (px == 0) {
                @set_color_config(px, py, C_L_B, .{ .routes = .{ .rx = .{EAST}, .tx = .{RAMP} } });                
            } else { // 0 < px < P+L-1
                @set_color_config(px, py, C_L_B, .{ .routes = .{ .rx = .{EAST}, .tx = .{RAMP, WEST} } });
            }

            // Step by step communication
            {
                @set_color_config(px, py, comm_even.c_right_send, .{ .routes = .{ .rx = .{RAMP}, .tx = .{EAST} } });
                @set_color_config(px, py, comm_even.c_right_recv, .{ .routes = .{ .rx = .{WEST}, .tx = .{RAMP} } });
            }

        }
    }

    px = 1;
    while (px < P+L) : (px += 2) {
        const memcpy_params = memcpy.get_params(px);

        py = 0;
        while (py < P) : (py += 1) {

            @set_tile_code(px, py, "shift.csl", .{
                .memcpy_params = memcpy_params,
                .comm_params = @concat_structs(comm_odd, .{.left_bd_color = C_L_B}),
                .P = P, .L = L, .Mt = Mt, .Nt = Nt,
            });

            if (px == (P+L-1)) {
                @set_color_config(px, py, C_L_B, .{ .routes = .{ .rx = .{RAMP}, .tx = .{WEST} } });
            } else if (px == 0) {
                @set_color_config(px, py, C_L_B, .{ .routes = .{ .rx = .{EAST}, .tx = .{RAMP} } });                
            } else { // 0 < px < P+L-1
                @set_color_config(px, py, C_L_B, .{ .routes = .{ .rx = .{EAST}, .tx = .{RAMP, WEST} } });
            }

            // Step by step communication
            {
                @set_color_config(px, py, comm_odd.c_right_send, .{ .routes = .{ .rx = .{RAMP}, .tx = .{EAST} } });
                @set_color_config(px, py, comm_odd.c_right_recv, .{ .routes = .{ .rx = .{WEST}, .tx = .{RAMP} } });
            }

        }
    }

    @export_name("W", [*]f16, true);
    @export_name("res", [*]f16, true);

    @export_name("init_task", fn()void);
    @export_name("shift_entry", fn()void);
    @export_name("shift_host", fn(i16, i16)void);

    @export_name("time_memcpy", [*]f32, true);
}
