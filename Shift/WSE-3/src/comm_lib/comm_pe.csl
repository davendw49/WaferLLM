param P: i16;
param L: i16;
param Mt: i16;
param Nt: i16;

var px: i16 = 0;
var py: i16 = 0;

param c_right_recv: color;
param c_right_send: color;

param left_bd_color: color;

var is_px_even: bool;

const right_recv_queue_id = @get_input_queue(2);
const right_send_queue_id = @get_output_queue(2);

const left_bd_recv_queue_id = @get_input_queue(3);
const left_bd_send_queue_id = @get_output_queue(3);

const right_recv_dsd = @get_dsd(fabin_dsd, .{
    .extent = Nt*Mt,
    .fabric_color = c_right_recv,
    .input_queue = right_recv_queue_id,
    .simd_mode = .{ .simd_64 = true },
});

const right_send_dsd = @get_dsd(fabout_dsd, .{
    .extent = Nt*Mt,
    .fabric_color = c_right_send,
    .output_queue = right_send_queue_id,
    .simd_mode = .{ .simd_64 = true },
});

const left_bd_recv_dsd = @get_dsd(fabin_dsd, .{
    .extent = 1,
    .fabric_color = left_bd_color,
    .input_queue = left_bd_recv_queue_id,
});

const left_bd_send_dsd = @get_dsd(fabout_dsd, .{
    .extent = 1,
    .fabric_color = left_bd_color,
    .output_queue = left_bd_send_queue_id,
});

const dummy = @zeros([1]f16);
var swap_ptr: [*]f16;
var tmp_0_ptr: [*]f16;
var tmp_1_ptr: [*]f16;
var buf_dsd_0 = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Nt*Mt} -> dummy[i] });
var buf_dsd_1 = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Nt*Mt} -> dummy[i] });
var bd_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{1} -> dummy[i] });

fn init_(_px: i16, _py: i16) void {
    px = _px;
    py = _py;

    if (px % 2 == 0) {
        is_px_even = true;
    } else {
        is_px_even = false;
    }
}

fn right_matrix_shift(buf_ptr_0: [*]f16, buf_ptr_1: [*]f16) void {
    tmp_0_ptr = buf_ptr_0;
    tmp_1_ptr = buf_ptr_1;

    for (@range(i16, 0, L, 1)) |i| {
        if (px == 0) {
            buf_dsd_0 = @set_dsd_base_addr(buf_dsd_0, tmp_0_ptr);
            @fmovh(right_send_dsd, buf_dsd_0);
        } else if (px == P + L - 1) {
            buf_dsd_1 = @set_dsd_base_addr(buf_dsd_1, tmp_1_ptr);
            @fmovh(buf_dsd_1, right_recv_dsd);
        } else {
            if (is_px_even) {
                buf_dsd_0 = @set_dsd_base_addr(buf_dsd_0, tmp_0_ptr);
                @fmovh(right_send_dsd, buf_dsd_0);
                buf_dsd_1 = @set_dsd_base_addr(buf_dsd_1, tmp_1_ptr);
                @fmovh(buf_dsd_1, right_recv_dsd);

                // swap buf_ptr_0 and buf_ptr_1
                swap_ptr = tmp_0_ptr;
                tmp_0_ptr = tmp_1_ptr;
                tmp_1_ptr = swap_ptr;
            } else {
                buf_dsd_1 = @set_dsd_base_addr(buf_dsd_1, tmp_1_ptr);
                @fmovh(buf_dsd_1, right_recv_dsd);
                buf_dsd_0 = @set_dsd_base_addr(buf_dsd_0, tmp_0_ptr);
                @fmovh(right_send_dsd, buf_dsd_0);

                // swap buf_ptr_0 and buf_ptr_1
                swap_ptr = tmp_0_ptr;
                tmp_0_ptr = tmp_1_ptr;
                tmp_1_ptr = swap_ptr;
            }
        }
    }

    if (L % 2 == 0 and px != (P + L - 1)) {
        buf_dsd_0 = @set_dsd_base_addr(buf_dsd_0, buf_ptr_0);
        buf_dsd_1 = @set_dsd_base_addr(buf_dsd_1, buf_ptr_1);
        @fmovh(buf_dsd_1, buf_dsd_0);
    }
}

fn left_broadcast() void {
    if (px == P + L - 1) {
        @fmovh(left_bd_send_dsd, bd_dsd);
    } else {
        @fmovh(bd_dsd, left_bd_recv_dsd);
    }
}

comptime {
    @block(right_recv_queue_id);
    @block(left_bd_recv_queue_id);
    if (@is_arch("wse3")) {
        @initialize_queue(right_recv_queue_id, .{.color = c_right_recv});
        @initialize_queue(right_send_queue_id, .{.color = c_right_send});
        @initialize_queue(left_bd_recv_queue_id, .{.color = left_bd_color});
        @initialize_queue(left_bd_send_queue_id, .{.color = left_bd_color});
    }
}