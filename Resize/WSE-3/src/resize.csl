param memcpy_params: comptime_struct;
param comm_params: comptime_struct;

param P_1: i16;
param P_2: i16;
param Mt_1: i16;
param Nt_1: i16;
param Mt_2: i16;
param Nt_2: i16;

const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);
const layout_module = @import_module("<layout>");

const comm_mod = @import_module("comm_lib/comm_pe.csl", @concat_structs(comm_params, .{
    .P_1 = P_1, .P_2 = P_2, .Mt_1 = Mt_1, .Nt_1 = Nt_1, .Mt_2 = Mt_2, .Nt_2 = Nt_2,
}));

var px: i16 = 0;
var py: i16 = 0;

var W_1_tile: [Mt_1*Nt_1]f16 = @zeros([Mt_1*Nt_1]f16);
var ptr_W_1: [*]f16 = &W_1_tile;
var W_1_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt_1*Nt_1} -> W_1_tile[i] });

var W_2_tile: [Mt_2*Nt_2]f16 = @zeros([Mt_2*Nt_2]f16);
var ptr_W_2: [*]f16 = &W_2_tile;
var W_2_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{Mt_2*Nt_2} -> W_2_tile[i] });

const timestamp = @import_module("<time>");
var tscStartBuffer = @zeros([timestamp.tsc_size_words]u16);
var tscEndBuffer = @zeros([timestamp.tsc_size_words]u16);
var time_buf_f32 = @zeros([3]f32);
var ptr_time_memcpy: [*]f32 = &time_buf_f32;

fn init_task() void {
    timestamp.enable_tsc();
    @assert(P_2 >= P_1);
    px = @as(i16, layout_module.get_x_coord());
    py = @as(i16, layout_module.get_y_coord());
  
    comm_mod.init_(px, py);
    sys_mod.unblock_cmd_stream();
}

fn resize_communication() void {
    comm_mod.right_resize();
    comm_mod.left_resize();
    resize_entry();
}

var total_repeat_times: i16 = 1;
var total_warmup_times: i16 = 0;

var repeat_times: i16 = 0; // Start from 0

fn resize_host(total_warmup_times_: i16, total_repeat_times_: i16) void {
    total_repeat_times = total_repeat_times_;
    total_warmup_times = total_warmup_times_;

    repeat_times = 0;

    resize_entry();
}

fn resize_entry() void {

    // Run (total_warmup_times + total_repeat_times) times; only the last `total_repeat_times` iterations are timed
    if (repeat_times == total_repeat_times + total_warmup_times) {
        exit();
    } else {
        if (repeat_times == total_warmup_times) {
            timestamp.get_timestamp(&tscStartBuffer);
        }

        repeat_times += 1;
        resize_communication();
    }
}

fn exit() void {
    timestamp.get_timestamp(&tscEndBuffer);
    timestamp.disable_tsc();

    f_memcpy_timestamps();
    sys_mod.unblock_cmd_stream();
}

fn f_memcpy_timestamps() void {
    var lo_ : u16 = 0;
    var hi_ : u16 = 0;
    var word : u32 = 0;

    lo_ = tscStartBuffer[0];
    hi_ = tscStartBuffer[1];
    time_buf_f32[0] = @bitcast(f32, (@as(u32,hi_) << @as(u16,16)) | @as(u32, lo_) );

    lo_ = tscStartBuffer[2];
    hi_ = tscEndBuffer[0];
    time_buf_f32[1] = @bitcast(f32, (@as(u32,hi_) << @as(u16,16)) | @as(u32, lo_) );

    lo_ = tscEndBuffer[1];
    hi_ = tscEndBuffer[2];
    time_buf_f32[2] = @bitcast(f32, (@as(u32,hi_) << @as(u16,16)) | @as(u32, lo_) );
}

comptime {
    @export_symbol(ptr_W, "W");
    @export_symbol(ptr_res, "res");

    @export_symbol(init_task);
    @export_symbol(resize_host);

    @export_symbol(ptr_time_memcpy, "time_memcpy");
}